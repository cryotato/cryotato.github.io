---
title: "Transliŋgual Engliʃh — 𖡉Kaomogliʃh"
date: 2024-07-20T19:31:53.906+0000
last_modified_at: 2025-04-03T13:08:54.803+0000
categories: [""]
toc: true
toc_label: "ϑawts"
toc_icon: "brain"  # corresponding Font Awesome icon name (without fa prefix)
tags: ["linguistics","orthography"]
description: "after experimentiŋ w/ ϑ’Neogliʃh writiŋ syſtem ï cooked ûp a year or so ago, enough has ɕhang’d for me to write a new manifeſto / guide…"
image:
  path: /assets/images/1_YTgbiT1uJmPfWDjGCpYXLA.jpeg
---

### Transliŋgual Engliʃh — 𖡉Kaomogliʃh


![\(it probably won't be\)](/assets/images/1_YTgbiT1uJmPfWDjGCpYXLA.jpeg)

\(it probably won't be\)


> All creativity is bureaucratically suppressed until there’s just a boring, grey, algorithmic internet left\. Ruled by robots feeding us bite\-sized bullshit in between ads\. And it’s the people pleading for inclusivity who create this ultimate exclusivity\. 





> — [some redditor](https://www.reddit.com/r/webdev/comments/vql26g/comment/ieqcnbj/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) 





after experimentiŋ 𝑤/ ϑ’Neogliʃh writiŋ syſtem ï cooked ûp a year or so ago, enůgh has ɕhang’d for me to write a new manifeſto / guide for its interpretation & use\. ϑ’project started as a way to streamline Engliʃh spelliŋ, ⅋ᵘᵗ it — its goals & its ideology, has evolved into someϑiŋ muɕh more\. ů can ϑink of ϑis as a Patɕh Ûpdate of 𖡉bug fixes, improvements &cᵆᵗᵉʳᵃ\. ï tryજ⁀➴to be consistent ⅋ut ϑere’ˢ nø strict right or wrøŋ way to use Neogliʃh, it’ˢ just anoϑer mode of creative expreſsion on ϑ’internet\. here’ʳᵉ a few ideological quirks ï personally adhere to:
### LOGOGRAΦY

as someone w/ an Asian background, a mountiŋ knowledge of 漢字, & an abuser of kaomoji, ï find profound beautεїз✧ in logograφy\., naturally, ï started l𓏗𓏗kiŋ for ways to briŋ ϑ’same magic to Neogliʃh in ways ϑat do nøt interfere w/ ϑ’legibility of ϑ’word itself\. ů may’ᵛᵉ spott’d some examples already\. here’ʳᵉ just a few examples:
- 𖹭 for l𖹭ve — can be used anywhere as a tonal marker, a replacement for “o”\. ïve found it useful to soften ϑ’blow of dry boring texts like “oh ok”→ “𖹭h 𖹭k”
- ɩ̈ for ϑ’self — ï gave him eyes\! used as a distinct “I”, making apostrophes in “I’m” or “I’ve” &cᷔ obsolete→ “ïm” & “ïve”
- ᴜ̊ for you — l𓏗𓏗ks like a dude, o beiŋ ϑ’head\. more on it bel̬ow…
- ✧ & εĭз for beautεĭз✧ — ϑey can eiϑer be used togeϑer or separately\. ϑ’spark “✧” can be used in place of ϑ’shortening of a common word used to exaggerate, like w/ “pretty” or “very” → “p✧” & “v✧”, while ϑ’butterflεĭз resembles an “ei” or “ie” so it can be used in place of words ϑat end in “y” like w/ “fairy” → “færiεĭз” \(dervived from ϑ’Early Modern Engliʃh spelling of færie\) \.
- 𓏗𓏗 for l𓏗𓏗kiŋ — self explanatory\. can’t really ϑink of anoϑer word to do w/ sight w/ a double o\.
- ⅋ for ⅋ᵘᵗ\(but\)— ϑ’ampersand is used to denote additional information & its use upside down symbolises ϑ’counter point beiŋ made\. formatted with small “ut” makes “⅋” look more like a “b”
- ø for nø — anoϑer replacement for o ϑat denotes a negative value, rejection, &cᷔ\.
- ô for ûp & do̬wn— ϑ’circumflex accent can be used to logograφically point\. ϑis might be annoyiŋ to ϑ’French, who use it to denote a ɕhange in pronounciation ⅋ut φuck ‘em\. ϑey can be also represent a rôof for hoûse or hôtel whiɕh ironically is ϑ’way ϑ’french spell it anyway\. w/ bel̬ow ů can add it to ϑ’l making it l𓏗𓏗k like an arrow➴
- ¿ for w¿at — denotes a question for w¿ats, w¿ys, w¿eres & so on\. ϑ’pronunciation of ϑ’Hs have been mostly phased out \(unless ů’re Irish or Scottish\) ů can get away w/ replacing ϑ’silent H w/ a tonal marker\. it ʃhůldn’ᵗ be used in contexts where ϑ’word isn’t beiŋ used to ask a question, like ϑ' “where" in ϑis sentence\. ϑis one’s still in beta & ïm nøt sure if ï like it or nøt yet\.
- or ꝡ ŵ w̃ for why what when
- Ꝭ for iꝬ — useful old latin ligature of “IS” ϑat can be used iṋ place of ‘s
- diacritic markers can generally be used to make simple emojis on tôp of text, like: c̥̥̥̥̆ryiŋ̥̥̥̥̆, ṡȃḋ, ϑa̍ňk̍s, ẘ0ẘ, t̋e̊ěhe̊e̋ೀ, &c as well as some simple numeric 漢字 like: on̅e tw̅̅o ϑre̅̅̅e \(based on 一二三\)


ϑese’re just a few ϑat’ve môre or leẞ ﬆuck for now\. playiŋ around & comiŋ ûp w/ ůr own can be really rewardiŋ\.
### HISTORY

while many rightfully argue modern Engliʃh’s spelliŋ conventions ﬆick to̊ close to tradition, ï feel it wůld be easier to lean into it, usiŋ old spelliŋs ϑat make use of archaic letters to specify its origins &cᵆᵗᵉʳᵃ, raϑer ϑan tryiŋજ⁀➴ to standardize a new, more phonetically accurate mode of spelliŋ\. ïm referring particularly to Latin æ & œ ϑat’ᵛᵉ largely been removed \(in different ways\) from Britiʃh & American Engliʃh, & French accent markers\. apart from words like færiεїз✧ or &cᵆᵗᵉʳᵃ \(et cetera\) ϑat ï mentioned earlier / have been usiŋ, oϑer examples include
- œstrogen \(latin\)
- archæology \(latin\)
- algæ \(latin, ï mean jee ï was seriously baffled by ϑ’spelling / proper pronunciation of ϑis one up till ï realized ϑ’ae at ϑ’end is supposed to be an æ\. \)
- poétique / poétic \(french\)
- hôtel \(french\)


some words \(like déjà vu & café\) already follow ϑis principle\.
### READABILITY \(𖡉BUG FIX\)

efforts to streamline “sh” “ch” “ou” “oo” &c into one character was met w/ a lot of confusion, it was counter\-intuitive to expect oϑers to understand letters from foreign alφabets\. so now ϑere’ˢ “ʃh” & “ɕh”\. it’ˢ a lot truer to ϑ’IPA whilst beiŋ really simple to figure øut\. plus ï just really like ϑ’way loŋ S looks \(ſ/ʃ\) \. maybe one day ïll be able to remove ϑ’Hs\. as for “ou”, ïve simply taken a trick out ϑ’Spaniards bꝏk \(refering to ϑ’eñe, whiɕh ironically ïve ɕhosen to abandon usiŋ\) & put ϑ’extra o abôve ϑ’U, creating “ů”\. ï ϑink it works quite well & seemleẞly in words like “cůld” & “wůld” or “bůrgeoisie" ⅋ut leẞ well in words w/ a bigger emphasis on ϑ’O rather ϑan ϑ’U like “abůt" \(about\) or “clůd” \(cloud\) & “ůt” \(øut\) & especially “růnd" \(round\) where ϑ’O is ironically ϑ’roundest part of ϑ’word\. ï usually just ɕhoose to opt øut of using it in words like ϑat\. ï also use it quite often nowadays as a standalone to replace “you” as “ᴜ̊” because it’ˢ more readable & familar to do it ϑat way ϑen to spell it like “yů”, & it resembles a person pictographically\. ï just worry it comes across as informal\. it’ˢ a vibe ï guess\. a similar ϑiŋ is sometimes done with oo → o̊ ⅋ut it oftentimes døesn’ᵗ come øut particularly readable\. ïm experimenting w/ ϑ’ligature “ꝏ” or “ҩ” instead ⅋ut it seems kinda pointleẞ\.

“ϑ” stuck around p✧ well, ïd guess its ϑanks to its resemblance to a cursive “d”, whiɕh eiϑer reminds people of AAVE used on ϑ’internet \(like “who dis” vs “who ϑis” &c\) or ϑ’vague use of “d” over “th” in Europe \(like ϑ’German “danke” vs “ϑanks”\) \. ïve also experimented w/ different forms of it like “δ” \(delta iꝬ͇nt̽ too far from a theta & iꝬ͇ actually quite intuitive to read, ⅋ut nøt as muɕh as cursive theta ɩ̈ ϑink \(δink\) because it can be mistaken for an S\) or “ɘ” / “ɵ” \(its written similarly as ϑ but fits in better w/ oϑer \(oɘer / oɵer\) lowercased letters, ⅋ut its resemblance to an e supersedes its resemblance to a Θ and Θ just l𓏗𓏗ks too muɕh like an O anyway\), or “ð” whiɕh ï ϑink \(ðink\) might still be on ϑ’table ⅋ut it might lꙭk too much like a d which can be quite confusing \(like with death it’s deaϑ vs deað, and i always intuitively incorrectly read ϑ’on̅e w/ ϑ’ð as “dead”\) \. “φ” seemed to do 𖹭k as well, maybe because it døesn’ᵗ l𓏗𓏗k to̊ far off from “ph”\. some times ï use it in place of “f” as well, mostly for profanity \(φuck, &c\) \.
#### AUTOHOTKEY

last time ï wrote of Neogliʃh ï talked about typiŋ all of ϑis out in Gboard, while ï still prefer ϑat way of typiŋ Kaomogliʃh, ïve come up wiϑ a new way of doiŋ so on PC usiŋ Autohotkey\. itꝬ a lil janky to type with because for ϑ’keys used, ϑ’character will only come out after ϑ’key has been lift’d\.

It works by treatiŋ ϑ’first letter as a modifier key\. so with “th” to “ϑ”, ᴜ̊ would hold T and ϑen press H\.

ϑ’code below also includes “ph” to “φ”, “bt” to “⅋”, “ ‘s ” to “Ꝭ”, “ae” to “æ”, “wy” to “ꝡ”, “sz” to “ẞ”, “yu” to “ᴜ̊”, “oe” to “œ”, “sh” to “ʃh”, “ch” to “ɕh”, “ng” to “ŋ”, “ i’ ” to “ï” and “ed” to “ ‘d ”\. it also checks if ctrl, shift, alt, or ϑ’windows key iꝬ press’d to make sure it doesn’t bug out shortcuts\.

ï know itꝬ meẞy ⅋ ïon rly feel like fixiŋ it… sozzy\.
```rust
#Requires AutoHotkey v2.0

; Track pressed states for first letters
isTPressed := false
isPPressed := false
isBPressed := false
isApostrophePressed := false
isAPressed := false
isWPressed := false
isSPressed := false
isYPressed := false
isOPressed := false
isNPressed := false
isCPressed := false
isIPressed := false
isEPressed := false

; Helper function to check if any modifier is pressed
HasModifier() {
    return GetKeyState("Ctrl") || GetKeyState("Shift") || GetKeyState("Alt") || GetKeyState("LWin") || GetKeyState("RWin")
}

; Add this variable to track if the key was pressed with modifiers
hadModifier := false

; First letter down handlers
*t:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}t"
        return
    }
    global isTPressed, isBPressed
    if isBPressed {
        Send "⅋"
        isBPressed := false
    } else {
        isTPressed := true
    }
}

*p:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}p"
        return
    }
    global isPPressed
    isPPressed := true
}

*b:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}b"
        return
    }
    global isBPressed
    isBPressed := true
}

*':: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}'"
        return
    }
    global isApostrophePressed, isIPressed, isEPressed
    if isIPressed {
        Send "ï"
        isIPressed := false
    } else {
        isApostrophePressed := true
    }
}

*a:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}a"
        return
    }
    global isAPressed
    isAPressed := true
}

*w:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}w"
        return
    }
    global isWPressed, isYPressed
    isWPressed := true
}

*y:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}y"
        return
    }
    global isYPressed, isWPressed
    if isWPressed {
        Send "ꝡ"
        isWPressed := false
    } else {
        isYPressed := true
    }
}

*s:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}s"
        return
    }
    global isSPressed, isApostrophePressed
    if isApostrophePressed {
        Send "Ꝭ"
        isApostrophePressed := false
    } else {
        isSPressed := true
    }
}

*o:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}o"
        return
    }
    global isOPressed
    isOPressed := true
}

*n:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}n"
        return
    }
    global isNPressed
    isNPressed := true
}

*c:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}c"
        return
    }
    global isCPressed
    isCPressed := true
}

*i:: {
    global hadModifier := HasModifier()
    if hadModifier {
        Send "{Blind}i"
        return
    }
    global isIPressed
    isIPressed := true
}

*i up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isIPressed
    if isIPressed {
        Send "i"
    }
    isIPressed := false
}

*e:: {
    global hadModifier := HasModifier()
    if hadModifier {
        Send "{Blind}e"
        return
    }
    global isEPressed, isAPressed, isOPressed
    if isAPressed {
        Send "æ"
        isAPressed := false
    } else if isOPressed {
        Send "œ"
        isOPressed := false
    } else {
        isEPressed := true
    }
}

*e up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isEPressed
    if isEPressed {
        Send "e"
    }
    isEPressed := false
}

*d:: {
    global hadModifier := HasModifier()
    if hadModifier {
        Send "{Blind}d"
        return
    }
    global isEPressed
    if isEPressed {
        Send "'d"
        isEPressed := false
    } else {
        Send "d"
    }
}

; First letter up handlers
*t up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isTPressed
    if isTPressed {
        Send "t"  
    }
    isTPressed := false
}

*p up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isPPressed
    if isPPressed {
        Send "p"
    }
    isPPressed := false
}

*b up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isBPressed
    if isBPressed {
        Send "b"
    }
    isBPressed := false
}

*' up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isApostrophePressed
    if isApostrophePressed {
        Send "'"
    }
    isApostrophePressed := false
}

*a up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isAPressed
    if isAPressed {
        Send "a"
    }
    isAPressed := false
}

*w up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isWPressed
    if isWPressed {
        Send "w"
    }
    isWPressed := false
}

*s up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isSPressed
    if isSPressed {
        Send "s"
    }
    isSPressed := false
}

*y up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isYPressed
    if isYPressed {
        Send "y"
    }
    isYPressed := false
}

*o up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isOPressed
    if isOPressed {
        Send "o"
    }
    isOPressed := false
}

*n up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isNPressed
    if isNPressed {
        Send "n"
    }
    isNPressed := false
}

*c up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isCPressed
    if isCPressed {
        Send "c"
    }
    isCPressed := false
}

; Second letter handlers
*h:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}h"
        return
    }
    global isTPressed, isPPressed, isSPressed, isCPressed
    if isTPressed {
        Send "ϑ" 
        isTPressed := false  
    } else if isPPressed {
        Send "φ"
        isPPressed := false
    } else if isSPressed {
        Send "ʃh"
        isSPressed := false
    } else if isCPressed {
        Send "ɕh"
        isCPressed := false
    } else {
        Send "h" 
    }
}

*g:: {
    if HasModifier() {
        Send "{Blind}g"
        return
    }
    global isNPressed
    if isNPressed {
        Send "ŋ"
        isNPressed := false
    } else {
        Send "g"
    }
}

*z:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}z"
        return
    }
    global isSPressed
    if isSPressed {
        Send "ẞ"
        isSPressed := false
    } else {
        Send "z"
    }
}

*u:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}u"
        return
    }
    global isYPressed
    if isYPressed {
        Send "ᴜ̊"
        isYPressed := false
    } else {
        Send "u"
    }
}
```

𓅮

ϑat is all\. remember to find ϑ’Beautεїз in Θiŋs\.

