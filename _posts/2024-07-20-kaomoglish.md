---
title: "TransliÅ‹gual EngliÊƒhâ€Šâ€” ğ–¡‰KaomogliÊƒh"
date: 2024-07-20T19:31:53.906+0000
last_modified_at: 2025-04-03T13:08:54.803+0000
categories: [""]
toc: true
toc_label: "Ï‘awts"
toc_icon: "brain"  # corresponding Font Awesome icon name (without fa prefix)
tags: ["linguistics","orthography"]
description: "after experimentiÅ‹ w/ Ï‘â€™NeogliÊƒh writiÅ‹ syÅ¿temÂ Ã¯ cookedÂ Ã»p aÂ year or soÂ ago, enough has É•hangâ€™d for me to write a new manifeÅ¿to / guideâ€¦"
image:
  path: /assets/images/1_YTgbiT1uJmPfWDjGCpYXLA.jpeg
---

### TransliÅ‹gual EngliÊƒhâ€Šâ€” ğ–¡‰KaomogliÊƒh


![\(it probably won't be\)](/assets/images/1_YTgbiT1uJmPfWDjGCpYXLA.jpeg)

\(it probably won't be\)


> All creativity is bureaucratically suppressed until thereâ€™s just a boring, grey, algorithmic internet left\. Ruled by robots feeding us bite\-sized bullshit in between ads\. And itâ€™s the people pleading for inclusivity who create this ultimate exclusivity\. 





> â€” [some redditor](https://www.reddit.com/r/webdev/comments/vql26g/comment/ieqcnbj/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button) 





after experimentiÅ‹ ğ‘¤/ Ï‘â€™NeogliÊƒh writiÅ‹ syÅ¿tem Ã¯ cooked Ã»p a year or so ago, enÅ¯gh has É•hangâ€™d for me to write a new manifeÅ¿to / guide for its interpretation & use\. Ï‘â€™project started as a way to streamline EngliÊƒh spelliÅ‹, â…‹áµ˜áµ— it â€” its goals & its ideology, has evolved into someÏ‘iÅ‹ muÉ•h more\. Å¯ can Ï‘ink of Ï‘is as a PatÉ•h Ã›pdate of ğ–¡‰bug fixes, improvements &cáµ†áµ—áµ‰Ê³áµƒ\. Ã¯ tryàªœâ€â´to be consistent â…‹ut Ï‘ereâ€™Ë¢ nÃ¸ strict right or wrÃ¸Å‹ way to use NeogliÊƒh, itâ€™Ë¢ just anoÏ‘er mode of creative expreÅ¿sion on Ï‘â€™internet\. hereâ€™Ê³áµ‰ a few ideological quirks Ã¯ personally adhere to:
### LOGOGRAÎ¦Y

as someone w/ an Asian background, a mountiÅ‹ knowledge of æ¼¢å­—, & an abuser of kaomoji, Ã¯ find profound beautÎµÑ—Ğ·âœ§ in logograÏ†y\., naturally, Ã¯ started lğ“—ğ“—kiÅ‹ for ways to briÅ‹ Ï‘â€™same magic to NeogliÊƒh in ways Ï‘at do nÃ¸t interfere w/ Ï‘â€™legibility of Ï‘â€™word itself\. Å¯ mayâ€™áµ›áµ‰ spottâ€™d some examples already\. hereâ€™Ê³áµ‰ just a few examples:
- ğ–¹­ for lğ–¹­veâ€Šâ€”â€Šcan be used anywhere as a tonal marker, a replacement for â€œoâ€\. Ã¯ve found it useful to soften Ï‘â€™blow of dry boring texts like â€œoh okâ€â†’ â€œğ–¹­h ğ–¹­kâ€
- É©Ìˆ for Ï‘â€™selfâ€Šâ€” Ã¯ gave him eyes\! used as a distinct â€œIâ€, making apostrophes in â€œIâ€™mâ€ or â€œIâ€™veâ€ &cá·” obsoleteâ†’ â€œÃ¯mâ€ & â€œÃ¯veâ€
- á´œÌŠ for youâ€Šâ€” lğ“—ğ“—ks like a dude, o beiÅ‹ Ï‘â€™head\. more on it belÌ¬owâ€¦
- âœ§ & ÎµÄ­Ğ· for beautÎµÄ­Ğ·âœ§â€Šâ€” Ï‘ey can eiÏ‘er be used togeÏ‘er or separately\. Ï‘â€™spark â€œâœ§â€ can be used in place of Ï‘â€™shortening of a common word used to exaggerate, like w/ â€œprettyâ€ or â€œveryâ€ â†’ â€œpâœ§â€ & â€œvâœ§â€, while Ï‘â€™butterflÎµÄ­Ğ· resembles an â€œeiâ€ or â€œieâ€ so it can be used in place of words Ï‘at end in â€œyâ€ like w/ â€œfairyâ€ â†’ â€œfÃ¦riÎµÄ­Ğ·â€ \(dervived from Ï‘â€™Early Modern EngliÊƒh spelling of fÃ¦rie\) \.
- ğ“—ğ“— for lğ“—ğ“—kiÅ‹â€Šâ€” self explanatory\. canâ€™t really Ï‘ink of anoÏ‘er word to do w/ sight w/ a double o\.
- â…‹ for â…‹áµ˜áµ—\(but\)â€” Ï‘â€™ampersand is used to denote additional information & its use upside down symbolises Ï‘â€™counter point beiÅ‹ made\. formatted with small â€œutâ€ makes â€œâ…‹â€ look more like a â€œbâ€
- Ã¸ for nÃ¸â€Šâ€” anoÏ‘er replacement for o Ï‘at denotes a negative value, rejection, &cá·”\.
- Ã´ for Ã»p &â€ŠdoÌ¬wnâ€”â€ŠÏ‘â€™circumflex accent can be used to logograÏ†ically point\. Ï‘is might be annoyiÅ‹ to Ï‘â€™French, who use it to denote a É•hange in pronounciation â…‹ut Ï†uck â€˜em\. Ï‘ey can be also represent a rÃ´of for hoÃ»se or hÃ´tel whiÉ•h ironically is Ï‘â€™way Ï‘â€™french spell it anyway\. w/ belÌ¬ow Å¯ can add it to Ï‘â€™l making it lğ“—ğ“—k like an arrowâ´
- Â¿Â for wÂ¿atâ€Šâ€” denotes a question for wÂ¿ats, wÂ¿ys, wÂ¿eres &Â soÂ on\. Ï‘â€™pronunciation of Ï‘â€™Hs have been mostly phased out \(unless Å¯â€™re Irish or Scottish\) Å¯ can get away w/ replacing Ï‘â€™silent H w/ a tonal marker\. it ÊƒhÅ¯ldnâ€™áµ— be used in contexts where Ï‘â€™word isnâ€™t beiÅ‹ used to ask a question, like Ï‘' â€œwhere" in Ï‘is sentence\. Ï‘is oneâ€™s still in beta & Ã¯m nÃ¸t sure if Ã¯ like it or nÃ¸t yet\.
- or ê¡ wÌ‚ wÌƒ for why what when
- ê¬ for iê¬â€Šâ€” useful old latin ligature of â€œISâ€ Ï‘at can be used inÌ­ place of â€˜s
- diacritic markers can generally be used to make simple emojis on tÃ´p of text, like: cÌ¥Ì¥Ì¥Ì†Ì¥ryiÅ‹Ì†Ì¥Ì¥Ì¥Ì¥, sÌ‡aÌ‘dÌ‡, Ï‘aÌnÌŒkÌs, wÌŠ0wÌŠ,Â tÌ‹eÌŠeÌŒheÌŠeÌ‹à³€, &c as well as some simple numeric æ¼¢å­— like: onÌ…e twÌ…Ì…o Ï‘reÌ…Ì…Ì…e \(based on ä¸€äºŒä¸‰\)


Ï‘eseâ€™re just a few Ï‘atâ€™ve moÌ‚re or leáº ï¬†uck for now\. playiÅ‹ around & comiÅ‹ Ã»p w/ Å¯r own can be really rewardiÅ‹\.
### HISTORY

while many rightfully argue modern EngliÊƒhâ€™s spelliÅ‹ conventions ï¬†ick toÌŠ close to tradition, Ã¯ feel it wÅ¯ld be easier to lean into it, usiÅ‹ old spelliÅ‹s Ï‘at make use of archaic letters to specify its origins &cáµ†áµ—áµ‰Ê³áµƒ, raÏ‘er Ï‘an tryiÅ‹àªœâ€â´ to standardize a new, more phonetically accurate mode of spelliÅ‹\. Ã¯m referring particularly to Latin Ã¦ & Å“ Ï‘atâ€™áµ›áµ‰ largely been removed \(in different ways\) from BritiÊƒh & American EngliÊƒh, & French accent markers\. apart from words like fÃ¦riÎµÑ—Ğ·âœ§ or &cáµ†áµ—áµ‰Ê³áµƒ \(et cetera\) Ï‘at Ã¯ mentioned earlier / have been usiÅ‹, oÏ‘er examples include
- Å“strogen \(latin\)
- archÃ¦ology \(latin\)
- algÃ¦ \(latin, Ã¯ mean jee Ã¯ was seriously baffled by Ï‘â€™spelling / proper pronunciation of Ï‘is one up till Ã¯ realized Ï‘â€™ae at Ï‘â€™end is supposed to be an Ã¦\. \)
- poÃ©tique / poÃ©tic \(french\)
- hÃ´tel \(french\)


some words \(like dÃ©jÃ  vu & cafÃ©\) already follow Ï‘is principle\.
### READABILITY \(ğ–¡‰BUG FIX\)

efforts to streamline â€œshâ€ â€œchâ€ â€œouâ€ â€œooâ€ &c into one character was met w/ a lot of confusion, it was counter\-intuitive to expect oÏ‘ers to understand letters from foreign alÏ†abets\. so now Ï‘ereâ€™Ë¢ â€œÊƒhâ€ & â€œÉ•hâ€\. itâ€™Ë¢ a lot truer to Ï‘â€™IPA whilst beiÅ‹ really simple to figure Ã¸ut\. plus Ã¯ just really like Ï‘â€™way loÅ‹ S looks \(Å¿/Êƒ\) \. maybe one day Ã¯ll be able to remove Ï‘â€™Hs\. as for â€œouâ€, Ã¯ve simply taken a trick out Ï‘â€™Spaniards bêk \(refering to Ï‘â€™eÃ±e, whiÉ•h ironically Ã¯ve É•hosen to abandon usiÅ‹\) & put Ï‘â€™extra o abÃ´ve Ï‘â€™U, creating â€œÅ¯â€\. Ã¯ Ï‘ink it works quite well & seemleáºly in words like â€œcÅ¯ldâ€ & â€œwÅ¯ldâ€ or â€œbÅ¯rgeoisie" â…‹ut leáº well in words w/ a bigger emphasis on Ï‘â€™O rather Ï‘an Ï‘â€™U like â€œabÅ¯t" \(about\) or â€œclÅ¯dâ€ \(cloud\) & â€œÅ¯tâ€ \(Ã¸ut\) & especially â€œrÅ¯nd" \(round\) where Ï‘â€™O is ironically Ï‘â€™roundest part of Ï‘â€™word\. Ã¯ usually just É•hoose to opt Ã¸ut of using it in words like Ï‘at\. Ã¯ also use it quite often nowadays as a standalone to replace â€œyouâ€Â as â€œá´œÌŠâ€ because itâ€™Ë¢ moreÂ readableÂ &Â familarÂ toÂ doÂ itÂ Ï‘at wayÂ Ï‘en toÂ spellÂ itÂ likeÂ â€œyÅ¯â€, & it resembles a person pictographically\. Ã¯ just worry it comes across as informal\. itâ€™Ë¢ a vibe Ã¯ guess\. a similar Ï‘iÅ‹ is sometimes done with oo â†’ oÌŠ â…‹ut it oftentimes dÃ¸esnâ€™áµ— come Ã¸ut particularly readable\. Ã¯m experimenting w/ Ï‘â€™ligature â€œêâ€ or â€œÒ©â€ instead â…‹ut it seems kinda pointleáº\.

â€œÏ‘â€ stuck around pâœ§ well, Ã¯d guess its Ï‘anks to its resemblance to a cursive â€œdâ€, whiÉ•h eiÏ‘er reminds people of AAVE used on Ï‘â€™internet \(like â€œwho disâ€ vs â€œwho Ï‘isâ€ &c\) or Ï‘â€™vague use of â€œdâ€ over â€œthâ€ in Europe \(like Ï‘â€™German â€œdankeâ€ vs â€œÏ‘anksâ€\) \. Ã¯ve also experimented w/ different forms of it like â€œÎ´â€ \(delta iê¬Í‡ntÌ½ too far from a theta & iê¬Í‡ actually quite intuitive to read, â…‹ut nÃ¸t as muÉ•h as cursive theta É©Ìˆ Ï‘ink \(Î´ink\) because it can be mistaken for an S\) or â€œÉ˜â€ / â€œÉµâ€ \(its written similarly as Ï‘ but fits in better w/ oÏ‘er \(oÉ˜er / oÉµer\) lowercased letters, â…‹ut its resemblance to an e supersedes its resemblance to a Î˜ and Î˜ just lğ“—ğ“—ks too muÉ•h like an O anyway\),Â orÂ â€œÃ°â€ whiÉ•h Ã¯ Ï‘ink \(Ã°ink\) might still be on Ï‘â€™tableÂ â…‹utÂ itÂ might lê™­k tooÂ muchÂ likeÂ aÂ dÂ whichÂ canÂ beÂ quiteÂ confusingÂ \(like with death itâ€™s deaÏ‘ vs deaÃ°, and i always intuitively incorrectly read Ï‘â€™onÌ…e w/ Ï‘â€™Ã° as â€œdeadâ€\)Â \. â€œÏ†â€ seemed to do ğ–¹­k as well, maybe because it dÃ¸esnâ€™áµ— lğ“—ğ“—k toÌŠ far off from â€œphâ€\. some times Ã¯ use it in place of â€œfâ€ as well, mostly for profanity \(Ï†uck, &c\) \.
#### AUTOHOTKEY

last time Ã¯ wrote of NeogliÊƒh Ã¯ talked about typiÅ‹ all of Ï‘is out in Gboard, while Ã¯ still prefer Ï‘at way of typiÅ‹ KaomogliÊƒh, Ã¯ve come up wiÏ‘ a new way of doiÅ‹ so on PC usiÅ‹ Autohotkey\. itê¬ a lil janky to type with because for Ï‘â€™keys used, Ï‘â€™character will only come out after Ï‘â€™key has been liftâ€™d\.

It works by treatiÅ‹ Ï‘â€™first letter as a modifier key\. so with â€œthâ€ to â€œÏ‘â€, á´œÌŠ would hold T and Ï‘en press H\.

Ï‘â€™code below also includes â€œphâ€ to â€œÏ†â€, â€œbtâ€ to â€œâ…‹â€, â€œ â€˜s â€ to â€œê¬â€, â€œaeâ€ to â€œÃ¦â€, â€œwyâ€ to â€œê¡â€, â€œszâ€ to â€œáºâ€, â€œyuâ€ to â€œá´œÌŠâ€, â€œoeâ€ to â€œÅ“â€, â€œshâ€ to â€œÊƒhâ€, â€œchâ€ to â€œÉ•hâ€, â€œngâ€ to â€œÅ‹â€, â€œ iâ€™ â€ to â€œÃ¯â€ and â€œedâ€ to â€œ â€˜d â€\. it also checks if ctrl, shift, alt, or Ï‘â€™windows key iê¬ pressâ€™d to make sure it doesnâ€™t bug out shortcuts\.

Ã¯ know itê¬ meáºy â…‹ Ã¯on rly feel like fixiÅ‹ itâ€¦ sozzy\.
```rust
#Requires AutoHotkey v2.0

; Track pressed states for first letters
isTPressed := false
isPPressed := false
isBPressed := false
isApostrophePressed := false
isAPressed := false
isWPressed := false
isSPressed := false
isYPressed := false
isOPressed := false
isNPressed := false
isCPressed := false
isIPressed := false
isEPressed := false

; Helper function to check if any modifier is pressed
HasModifier() {
    return GetKeyState("Ctrl") || GetKeyState("Shift") || GetKeyState("Alt") || GetKeyState("LWin") || GetKeyState("RWin")
}

; Add this variable to track if the key was pressed with modifiers
hadModifier := false

; First letter down handlers
*t:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}t"
        return
    }
    global isTPressed, isBPressed
    if isBPressed {
        Send "â…‹"
        isBPressed := false
    } else {
        isTPressed := true
    }
}

*p:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}p"
        return
    }
    global isPPressed
    isPPressed := true
}

*b:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}b"
        return
    }
    global isBPressed
    isBPressed := true
}

*':: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}'"
        return
    }
    global isApostrophePressed, isIPressed, isEPressed
    if isIPressed {
        Send "Ã¯"
        isIPressed := false
    } else {
        isApostrophePressed := true
    }
}

*a:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}a"
        return
    }
    global isAPressed
    isAPressed := true
}

*w:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}w"
        return
    }
    global isWPressed, isYPressed
    isWPressed := true
}

*y:: {
        global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}y"
        return
    }
    global isYPressed, isWPressed
    if isWPressed {
        Send "ê¡"
        isWPressed := false
    } else {
        isYPressed := true
    }
}

*s:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}s"
        return
    }
    global isSPressed, isApostrophePressed
    if isApostrophePressed {
        Send "ê¬"
        isApostrophePressed := false
    } else {
        isSPressed := true
    }
}

*o:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}o"
        return
    }
    global isOPressed
    isOPressed := true
}

*n:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}n"
        return
    }
    global isNPressed
    isNPressed := true
}

*c:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}c"
        return
    }
    global isCPressed
    isCPressed := true
}

*i:: {
    global hadModifier := HasModifier()
    if hadModifier {
        Send "{Blind}i"
        return
    }
    global isIPressed
    isIPressed := true
}

*i up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isIPressed
    if isIPressed {
        Send "i"
    }
    isIPressed := false
}

*e:: {
    global hadModifier := HasModifier()
    if hadModifier {
        Send "{Blind}e"
        return
    }
    global isEPressed, isAPressed, isOPressed
    if isAPressed {
        Send "Ã¦"
        isAPressed := false
    } else if isOPressed {
        Send "Å“"
        isOPressed := false
    } else {
        isEPressed := true
    }
}

*e up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isEPressed
    if isEPressed {
        Send "e"
    }
    isEPressed := false
}

*d:: {
    global hadModifier := HasModifier()
    if hadModifier {
        Send "{Blind}d"
        return
    }
    global isEPressed
    if isEPressed {
        Send "'d"
        isEPressed := false
    } else {
        Send "d"
    }
}

; First letter up handlers
*t up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isTPressed
    if isTPressed {
        Send "t"  
    }
    isTPressed := false
}

*p up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isPPressed
    if isPPressed {
        Send "p"
    }
    isPPressed := false
}

*b up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isBPressed
    if isBPressed {
        Send "b"
    }
    isBPressed := false
}

*' up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isApostrophePressed
    if isApostrophePressed {
        Send "'"
    }
    isApostrophePressed := false
}

*a up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isAPressed
    if isAPressed {
        Send "a"
    }
    isAPressed := false
}

*w up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isWPressed
    if isWPressed {
        Send "w"
    }
    isWPressed := false
}

*s up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isSPressed
    if isSPressed {
        Send "s"
    }
    isSPressed := false
}

*y up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isYPressed
    if isYPressed {
        Send "y"
    }
    isYPressed := false
}

*o up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isOPressed
    if isOPressed {
        Send "o"
    }
    isOPressed := false
}

*n up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isNPressed
    if isNPressed {
        Send "n"
    }
    isNPressed := false
}

*c up:: {
    global hadModifier
    if hadModifier {
        hadModifier := false
        return
    }
    global isCPressed
    if isCPressed {
        Send "c"
    }
    isCPressed := false
}

; Second letter handlers
*h:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}h"
        return
    }
    global isTPressed, isPPressed, isSPressed, isCPressed
    if isTPressed {
        Send "Ï‘" 
        isTPressed := false  
    } else if isPPressed {
        Send "Ï†"
        isPPressed := false
    } else if isSPressed {
        Send "Êƒh"
        isSPressed := false
    } else if isCPressed {
        Send "É•h"
        isCPressed := false
    } else {
        Send "h" 
    }
}

*g:: {
    if HasModifier() {
        Send "{Blind}g"
        return
    }
    global isNPressed
    if isNPressed {
        Send "Å‹"
        isNPressed := false
    } else {
        Send "g"
    }
}

*z:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}z"
        return
    }
    global isSPressed
    if isSPressed {
        Send "áº"
        isSPressed := false
    } else {
        Send "z"
    }
}

*u:: {
    global hadModifier := HasModifier()  ; Store the modifier state
    if hadModifier {
        Send "{Blind}u"
        return
    }
    global isYPressed
    if isYPressed {
        Send "á´œÌŠ"
        isYPressed := false
    } else {
        Send "u"
    }
}
```

ğ“…®

Ï‘at is all\. remember to find Ï‘â€™BeautÎµÑ—Ğ· in Î˜iÅ‹s\.

